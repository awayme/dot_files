" vim: set sw=4 ts=4 sts=4 et tw=78 foldmarker={,} foldlevel=0 foldmethod=marker spell:
"

if !exists('g:spf13_edit_config_mapping')
    let s:spf13_edit_config_mapping = '<leader>ev'
else
    let s:spf13_edit_config_mapping = g:spf13_edit_config_mapping
endif
if !exists('g:spf13_apply_config_mapping')
    let s:spf13_apply_config_mapping = '<leader>sv'
else
    let s:spf13_apply_config_mapping = g:spf13_apply_config_mapping
endif
execute "unmap " . s:spf13_edit_config_mapping
execute "unmap " . s:spf13_apply_config_mapping

set wrap

unmap <
unmap >

set guifont=Monospace\ 13

set fileencodings=utf-8,chinese,GB18030,latin-1
set fileformats=unix,dos,mac "Default file types

set foldmethod=marker

set nospell

map <C-j> <C-W>j
map <C-k> <C-W>k
map <C-h> <C-W>h
map <C-l> <C-W>l

"  In visual mode when you press * or # to search for the current selection
vnoremap <silent> * :call VisualSearch('f')<CR>
vnoremap <silent> # :call VisualSearch('b')<CR>

" When you press gv you vimgrep after the selected text
vnoremap <silent> gv :call VisualSearch('gv')<CR>

function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction 

" From an idea by Michael Naumann
function! VisualSearch(direction) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

" => unite {{{2
nnoremap <leader>s :Unite -start-insert buffer file_mru file <CR>

let g:unite_source_history_yank_enable=1
let g:unite_source_file_mru_long_limit = 500

" Close the current buffer
map <leader>bd :Bclose<cr>

command! Bclose call <SID>BufcloseCloseIt()
function! <SID>BufcloseCloseIt()
   let l:currentBufNum = bufnr("%")
   let l:alternateBufNum = bufnr("#")

   if buflisted(l:alternateBufNum)
     buffer #
   else
     bnext
   endif

   if bufnr("%") == l:currentBufNum
     new
   endif

   if buflisted(l:currentBufNum)
     execute("bdelete! ".l:currentBufNum)
   endif
endfunction

let g:UltiSnipsSnippetDirectories=['UltiSnips', '/home/dersu/.vim/PluginConf/UltiSnips']


" => YouCompleteMe {{{2
" for ycm
" let g:ycm_error_symbol = '>>'
" let g:ycm_warning_symbol = '>*'
" let g:ycm_autoclose_preview_window_after_completion = 1
let g:ycm_server_python_interpreter = '/usr/bin/python'
nnoremap <leader>jd :YcmCompleter GoToDefinitionElseDeclaration<CR>

" => indent guides{{{2
let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_start_level = 2
let g:indent_guides_guide_size = 1

" command! DlogFrame :r !ssh -i /home/dersu/Backup/Dropbox/Backup/keys/ec2/ec2-dev-ubuntu.pem ubuntu@tei2.info outlinerHelper/combinelinux.py
" command! DlogFrame :r !cus-taskwarrior.py
command! DlogFrame :r !~/Data/scripts/Self-productive/timecamp/env/bin/python ~/Data/scripts/Self-productive/timecamp/timecamp.py -e --startdate `date -d yesterday +\%Y-\%m-\%d`
" command! DlogFrame :r !~/Data/My_Scripts/Self-productive/timecamp/env/bin/python ~/Data/My_Scripts/Self-productive/timecamp/timecamp.py -e --startdate "strftime("%Y%m%d")"
" command! DlogFrame :r !/home/dersu/Backup/Dropbox/Apps/scripts/outlinerHelper/outlinerHelper.py --mode gen -o /home/dersu/Backup/Dropbox/Briefcase/Checklist/ToDo_Outline.otl
command! -nargs=1 DlogFrameDate :r !~/Data/scripts/Self-productive/timecamp/env/bin/python ~/Data/scripts/Self-productive/timecamp/timecamp.py -e --startdate "<args>"
" command! -nargs=1 DlogFrameDate :r !~/Data/My_Scripts/Self-productive/timecamp/env/bin/python ~/Data/My_Scripts/Self-productive/timecamp/timecamp.py -e --startdate "<args>" --enddate "<args>"
